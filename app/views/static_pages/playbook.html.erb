<h1>Time</h1>

<p>I work a sustainable pace.  I work three days for clients on consulting, and two days on "investment time".  I typically spend Monday - Wednesday on client work and Thursday - Friday on investment.</p>

<p>If there is a company holiday during the week, or if I am sick or unexpectedly absent from client work, I will use investment days as an extra client day to avoid slipping behind schedule.</p>

<p>When taking a planned vacation for attending a conference spanning multiple days, I generally do not "make up" client work on investment days.</p>

<p>Sending off-hours communication may create an unintended sense of urgency with the recipients of my message.  I will avoid creating that urgency when possible.</p>

<p>Unless actually urgent, I will generally ignore off-hour messages which I  receive and handle them once I am back at work.</p>

<h1>Investment</h1>

<p>Investment time is time for investment in myself, my company, and my community.  Primarily this means doing something that interests me like learning a new programming language, contributing to open source, discussing interesting things, attending community events, or reading an educational book.  The goal is to encourage myself to improve and share my knowledge.</p>

<p>Ideas for investment time include:</p>
<ul>
  <li>Contribute to open source software</li>
  <li>Write a blog post</li>
  <li>Work on conference and meetup talks and proposals</li>
  <li>Volunteer mentor for another solid learning organization</li>
  <li>Meet someone new or make an exsiting relationship stronger</li>
  <li>Answer questions on StackOverflow</li>
  <li>Build on an idea of my own</li>
</ul>

<h1>Web Apps</h1>

<p>I primarily develop in Ruby on Rails. It’s a robust, proven framework with a large community. It’s well structured, so whether the project is brand new or 5 years old, it’s familiar to other developers and the learning curve won’t be steep. It makes security easy so I can focus on features instead of worrying about cross-site scripting or SQL injection. Out of the box we get an admin interface. The ORM is really nice. We have wonderful deployment tools built and ready to go. Most importantly, there’s a large body of knowledge sitting around you that is intimately familiar with Rails.</p>

<p>If you decide to go with another framework, that’s cool. I only ask that you consider how it will impact development speed of your project. Ask yourself this: Will others have to learn a new language? Is this framework well supported? What does this framework give me that Rails doesn’t?</p>

<p>Along with Rails, we like to stick with the standards - HTML, CSS, JavaScript and PostgreSQL. They’re flexible, proven, avoid vendor lock-in, work on tons of devices, and most devs are familiar with them. Please no Flash.</p>

<p>Outside of the Ruby on Rails stack, I will develop in the Python stack if requested.</p>

<h1>Programming Languages</h1>

<p>Examples of languages we typically use are:</p>
<ul>
  <li>Ruby: My server-side preference</li>
  <li>Python</li>
  <li>JavaScript</li>
</ul>

<p>"Server-side" means code that is run on servers provided by the application hosting company.  "Client-side" means code that is run in users' web browswers.</p>

<h1>Frameworks</h1>

<p>Ruby on Rails, Node.js, and other libraries are frameworks that require developers know the underlying language such as Ruby or JavaScript.</p>

<p>Examples of frameworks we typically use are:</p>
<ul>
  <li>Ruby on Rails</li>
  <li>Sinatra</li>
  <li>Django</li>
  <li>Flask</li>
  <li>jQuery</li>
  <li>Angular.js</li>
  <li>Ember.js</li>
</ul>

<p>A framework is a library that makes performing a particular task in a programming language easier. Like the framework of a house, it is there when we begin programming and is always there giving the program structure and support.</p>

<p>It can be difficult to switch from one framework to another. The more code that's written specifically for Rails, the harder it will be to switch to Django. That would approach "total rewrite" territory.</p>

<h1>Databases</h1>

<p>For data that must be saved and stored correctly, I use PostgreSQL (I usually refer to it as "Postgres").</p>

<p>It's a 30 year old open source database that is highly respected, well supported by documentation and hosting providers, and used by any developer who knows the SQL standard.</p>

<p>In recent years, a movement called NoSQL has gained popularity. Best translated as "not only SQL", tremendous effort has been made to create different kinds of databases for different use cases, often based off academic or industry research.</p>

<p>My most frequently used NoSQL database is Redis, which I use for storing transient, high quantity read/write data such as activity feeds, tags, background jobs, sessions, tokens, and counters.</p>

<p>Redis is reliable, open-source, and simple. It offers high performance and reliable predictions of its performance. It can flexibly model different data sets but I typically use it for small data structures, not large images, videos, or text documents.</p>

<p>I typically use Redis to Go to host my production Redis databases.</p>

<h1>Licenses</h1>

<p>In contrast with a proprietary license, the source code of an open source program is made available for review, modification and redistribution. The difference between open source licenses is what we can and can't do with the source code.</p>

<p>Open source licenses can be divided in two categories: permissive and copyleft.</p>

<p>Permissive examples include:</p>
<ul>
  <li>Berkeley Software Distribution (BSD) licenses</li>
  <li>MIT license</li>
  <li>Apache license</li>
  <li>A copyleft example is the General Public License (GPL).</li>
</ul>

<p>Both categories have the purpose of establishing the copyright holder for the software, granting users the right to copy, modify and redistribute it, protecting the copyright holder from any potential guarantees that the software may provide (software is provided as-is), and optionally imposing some restrictions.</p>

<p>Permissive licenses let us modify a program, redistribute it, and even sell it. We can embed or link code with other programs without restriction or explicit permission by the copyright holder.</p>

<p>Copyleft licenses only allow us to link or distribute code with other code that has the same license. It also forces modifications to be released under the same license. Combining anything with the GPL makes it GPL.</p>

<p>Non-copyleft licenses do not enforce derivative works to also be open source.</p>

<p>Some software is released under a dual license: both a permissive and copyleft license. This provides developers who use the dual licensed code to apply the license that better suits their needs.</p>

<p>Most of the software we use has a permissive license:</p>
<ul>
  <li>PostgreSQL, PostgreSQL License (BSD based)</li>
  <li>Redis, BSD</li>
  <li>Ruby (MRI), Ruby license (BSD based)</li>
  <li>Ruby on Rails, MIT</li>
  <li>jQuery, Dual MIT and GPL</li>
</ul>

<h1>Developing</h1>

<p>The majority of my development practices follow practices detailed in Kent Beck's classic Extreme Programming Explained: Embrace Change and in Gerald Weinberg's The Psychology of Computer Programming.</p>

<h2>Version Control</h2>

<p>I always use source code control. It's like a time machine. I can work in parallel universes of my source code, experimenting without fear of losing work. Roll back if something goes wrong.</p>

<p>Git is an open source source code control system written by Linus Torvalds. It's fast and great for working in branches.</p>

<p>I use GitHub for hosting my git repositories.</p>

<h2>Style Guide</h2>

<p>I write code in a consistent style that emphasizes cleanliness and  communication.</p>

<p>High level guidelines:</p>
<ul>
  <li>Be consistent.</li>
  <li>Don't rewrite existing code to follow this guide.</li>
  <li>Don't violate a guideline without a good reason.</li>
  <li>A reason is good when you can convince a others.</li>
</ul>

<h2>Test-Driven Development</h2>

<p>Test-Driven Development (TDD) is perhaps the most important Extreme Programming (XP) rule that I practice.</p>

<p>Business benefits of TDD:</p>
<ul>
  <li>Deliver more value, faster</li>
  <li>Always ship working software</li>
  <li>Adapt to change quickly</li>
</ul>

<p>Code benefits of TDD:</p>
<ul>
  <li>Readable specs and code</li>
  <li>Clean public interfaces</li>
  <li>Decoupled modules</li>
</ul>

<p>Process benefits of TDD:</p>
<ul>
  <li>Regression safety net</li>
  <li>Fearless refactoring</li>
  <li>Team trust</li>
</ul>

<p>At a high level, how to test is very simple:</p>
<ul>
  <li>Write test first.</li>
  <li>Red-Green-Refactor cycle.</li>
</ul>

<h2>Acceptance Tests</h2>

<p>Acceptance tests are code created from jobs stories. This code is run against the application. When executed for the first time, the test will fail. I then write application code until the test passes.</p>

<p>When the test passes, then I commit the code into version control with a message such as: <code>Guest creates pledge</code></p>

<p>The code is then run on the Continuous Integration server to make sure the acceptance test still passes in an environment that matches the production environment.</p>

<p>Meanwhile, the code is pushed to the staging environment and I test it in the browser.</p>

<p>When the acceptance test is green for the CI server and I am satisfied that the jobs story is complete on staging, the feature can be deployed to production at will. This can result in features being pushed to production very frequently, and therefore more value is being delivered to customers sooner.</p>

<h2>Refactoring</h2>

<p>The third step of the "red, green, refactor" step is refactoring, the process of improving the design of existing code without altering its external behavior. It's a critical step in the process.</p>

<h2>Production</h2>

<p>We live in a magical modern era where many problems have already been solved for us. We focus on the client's product as much as possible and outsource operations as much as possible to external services.</p>

<p>This saves time and money. We can get started using those services in minutes. Our clients pay a service tens or hundreds of dollars per month instead of paying developers thousands or tens of thousands.</p>

<p>We often create a Google spreadsheet listing the monthly cost, description, and credentials of each of our clients' external services. It includes line items like GitHub, Heroku, SendGrid, New Relic, Airbrake, and Splunk.</p>

<h1>Hosting</h1>

<p>I use Heroku. It's a platform built on Amazon's cloud infrastructure. It is simple to use when our app is just a toy and is built to scale up for high concurrency or high sustained load.</p>

<p>Like Rails, Heroku uses conventions to make decisions for us that are unnecessary for us to make. Some things like web servers and app servers are solved problems. They act as our outsourced operations team. The amount of time I can focus on the product instead of solved problems is worth the premium over bare-bones Amazon Web Services.</p>

<p>The cloud promises lower operating costs, especially at the beginning when capacity can be lower. Forget about sunk costs of expensive servers.</p>

<p>The cloud and the services it enables will empower our clients' businesses to start and operate in a manner that has never been possible before without significant upfront investment.</p>

<p>If I offer file uploads for features like user avatars, I upload them to Amazon S3.</p>

<p>I also serve my images, CSS, and JavaScript assets from a CDN such as Fastly.</p>

<h1>Performance Monitoring</h1>

<p>I use NewRelic (Free-$100s/month) to monitor performance of production applications.</p>

<p>Debugging performance might be the best part of a developer's job. There's a clear, numeric problem. When I fix it, that number improves. I can say things like "I made this 175% better."</p>

<p>There's many established techniques for fixing performance problems. A number of them come "for free" with Rails + Heroku:</p>
<ul>
  <li>Amazon server clusters</li>
  <li>gzipping</li>
  <li>Asset pipeline</li>
  <li>SQL query caching</li>
</ul>

<p>A number of them require developer thought:</p>
<ul>
  <li>Database indexing</li>
  <li>Eager loading</li>
  <li>HTTP caching</li>
</ul>

<p>Page caching is the heaviest handed technique I have, but if I can cache an entire page and push it into a CDN, that will be the fastest option.</p>

<h1>Error Tracking</h1>

<p>I use Airbrake Bug Tracker (Free-$25/month).</p>

<h1>Transactional Email</h1>

<p>I use SendGrid (Free-$400/month) to have our application deliver email to users, known as transactional email.</p>

<p>Examples of transactional email are:</p>
<ul>
  <li>Confirmations</li>
  <li>Follow ups after the first 3 days of use</li>
  <li>Free trial is expiring</li>
  <li>Message another user in the system</li>
</ul>

<p>I use SendGrid directly, not via the Heroku add-on, in order to avoid being lumped under the same IP group as others on Heroku (who might be misbehaving).</p>

<h1>Payment Processing</h1>

<p>For collecting payments from users via credit or debit card, I use Stripe. It is a payment gateway and merchant account. I also use it for recurring billing.</p>

<p>Charges for Stripe will vary depending on usage. Successful charges are 2.9% + 30 cents. There are no setup fees, monthly fees, or card storage fees.</p>

<p>For sending money to users' bank accounts via ACH, I use Balanced.</p>

